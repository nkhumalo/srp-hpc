c-----------------------------------------------------------------------
c
!> \ingroup wfn1
!> @{
!>
!> \file wfn1_e_g_2el_corr.F
!> The correlation energy based on $\mathrm{H}_2$.
!>
!> @}
!>
!> \ingroup wfn1_priv
!> @{
!>
!> \brief Evaluate the electron correlation energy
!>
!> This subroutine evaluates the correlation energy based on the
!> Full-CI energy for $\matrm{H}_2$ in a minimal basis set.
!> The correlation energy is defined as the difference between the
!> Full-CI energy and the regular uncorrelated energy. Hence, adding
!> the correlation energy to the uncorrelated energy should produce
!> the Full-CI energy. Note again, this energy expression is only
!> exact for 2-electron systems in a 2 spatial orbital basis set.
!> For other systems the expression will be an approximation.
!>
!> Note that because this energy expression is based on a closed
!> shell 2-electron system the correlation energy does not include
!> any exchange terms. It only includes correlations between 
!> $\alpha$ and $\beta$-electrons.
!>
!> Note that this energy expression ensures that no self-interaction
!> terms arise. Hence the energy is self-interaction free. However,
!> it is not clear that this energy expression can be cast as being
!> generated by an N-representable density matrix.
!>
!> Note that the Coulomb terms are added on to the v_dc_a and v_dc_b
!> vectors as those contributions are diagonal in the natural orbital
!> basis (just as the 1-electron terms are). The exchange terms do not
!> have this property and are therefore immediately transformed and
!> added onto the correlation function Fock matrices.
!>
!> On the memory management aspects there are costs associated with
!> allocating memory on the heap as in the Fortran ALLOCATE statement.
!> To avoid these overheads, in particular in the inner loops, Fortran
!> POINTERs are used. This means that the actual memory is associated
!> with buffers allocated outside the loops. The pointers are set 
!> inside the loops to provide convenient array views on the memory. 
!> For clarity pairs of variables are used. The ALLOCATABLE arrays
!> having names BUF_<name> are the buffers that hold the actual memory.
!> Associated with each such array is a POINTER <name> that points to
!> BUF_<name> and provides an appropriate number of dimensions and
!> corresponding index limits.
!>
!> In addition this subroutine inherently deals with \f$\alpha\$ and
!> \f$\beta\f$-spin variables. Variables related to \f$\alpha\f$-spin
!> electrons are identified by names with a trailing "_a" whereas 
!> \f$\beta\f$-electron variables are identified by names with a
!> trailing "_b".
!>
!> Another naming convention is that variables include the remaining
!> indeces. For example \f$\gamma_{adj}\f$ given above would have a
!> name that lists the remaining indeces \f$a, d, j\f$ and the order
!> of these indeces corresponds to the order of the dimensions of the
!> 3-dimensional tensor.
!>
!> ### References ###
!>
!> [1] A.-L. Cauchy, "Sur les formules qui résultent de l'emploi du
!>     signe > ou <, et sur les moyennes entre plusieurs quantités",
!>     In Book: Cours d'analyse de l'École Royale Polytechnique, (1821).
!>     Reprinted in Cambridge Library Collection - Mathematics,
!>     Cambridge University Press (2009), pp. 438-459, DOI:
!>     <a href="https://dx.doi.org/10.1017/CBO9780511693328.017>
!>     10.1017/CBO9780511693328.017</a>.
!>
!> [2] V. Bouniakowsky, "Sur quelques inegalités concernant les
!>     intégrales aux différences finies", Memoires de L'Academie
!>     Imperiale des Sciences de St.-Petersbourg, VII, 1 (1859) Nr. 9,
!>     pp. 1-18, URL:
!>     <a href="https://books.google.com/books?id=wZhFAAAAcAAJ>
!>     books.google.com/books?id=wZhFAAAAcAAJ</a>.
!>
!> [3] H. A. Schwarz, "Über ein Flächen kleinsten Flächeninhalts
!>     betreffendes Problem der Variationsrechnung", Acta Societatis
!>     Scientiarum Fennicae, XV: 318 (1885), URL:
!>     <a href="https://books.google.com/books?id=BXtIAQAAMAAJ">
!>     https://books.google.com/books?id=BXtIAQAAMAAJ</a>.
!>
!> [4] J. M. Steele, "The Cauchy-Schwarz Master Class", The Mathematical
!>     Association of America (2004), ISBN: 
!>     <a href="https://isbnsearch.org/isbn/052154677X">
!>     0-521-54677-X</a>.
!>
!> [5] H. J. J. van Dam, "An N-representable Hartree-Fock approach for
!>     non-idempotent density matrixes", in preparation (08/31/2017).
!>
!> ### TO DO ###
!>
!> 1. Work out whether a given processor needs to execute anything
!>    for a given index of ld, lc, lb, or la and skip empty loops.
!>    At the moment a simple task counter is checked in the inner most
!>    loop. Skipping loop bodies in outer loops can bring further 
!>    efficiency improvements.
!>
!> 2. It seems like in some places consecutive jj loops could be merged
!>    with the potential or reducing the order of intermediate tensors
!>    by 1. If this is actually possible then this could save memory
!>    as well as reduce memory access both of which would be beneficial.
!>
      subroutine wfn1_e_g_2el_corr(wfn1_param,wfn1_inst,wfn1_mat,
     &                             wfn1_wave,wfn1_deriv,v_dc_a,v_dc_b,
     &                             g_x_aa,g_x_bb,g_dx_aa,g_dx_bb,
     &                             E_corr)
      implicit none
c
#include "wfn1_param.fh"
#include "wfn1_matcnst.fh"
#include "wfn1_wfn.fh"
#include "wfn1_drv.fh"
#include "errquit.fh"
#include "global.fh"
#include "mafdecls.fh"
#include "bas.fh"
c
      type(wfn1_prm),     intent(in) :: wfn1_param ! the job parameters
      type(wfn1_prminst), intent(in) :: wfn1_inst  ! the job instances
      type(wfn1_matcnst), intent(in) :: wfn1_mat   ! matrix constants
      type(wfn1_wfn),     intent(in) :: wfn1_wave  ! the wavefunction
c
      type(wfn1_drv),  intent(inout) :: wfn1_deriv ! the derivatives
c
c     Correlation function Fock matrices in the natural orbital basis
c     alpha-, and beta-spin respectively (excluding exchange)
c
      double precision, intent(inout) :: v_dc_a(1:wfn1_param%nmo)
      double precision, intent(inout) :: v_dc_b(1:wfn1_param%nmo)
c
c     This implementation assumes that g_x_aa, g_x_bb, g_dx_aa,
c     and g_dx_bb all have the same data distribution. If the actual
c     data distributions are different then this will not affect the
c     results as these differences will be resolved by the Global
c     Arrays. However, this may generate additional communication and
c     hence reduce the efficiency.
c
c     OBSOLETE:
c     Nmo x nmo global arrays for the 2RDM exchange diagonals.
c     See exchange terms of Eq.(34) of [5].
c
      integer, intent(in) :: g_x_aa ! exchange alpha-alpha block
      integer, intent(in) :: g_x_bb ! exchange beta-beta block
c
c     OBSOLETE:
c     Nmo x nmo global arrays for the 2RDM exchange diagonals
c     derivatives. See the diagonal terms of Eq.(119) of [5].
c
      integer, intent(in) :: g_dx_aa ! exchange alpha-alpha block
      integer, intent(in) :: g_dx_bb ! exchange beta-beta block
c
c     The electron correlation energy [5]:
c
      double precision, intent(out) :: E_corr ! The correlation energy
c
c     Local variables:
c
      integer :: nproc ! the number of processors
      integer :: iproc ! the rank of this processor
      integer :: jproc ! a counter over processors
      integer :: itask ! the current task number
c
      integer :: nbf   ! the number of basis functions
      integer :: nmo   ! the number of MOs
      integer :: ne_a  ! the number of alpha-electrons
      integer :: ne_b  ! the number of beta-electrons
c
      integer :: ii, jj, kk, ll ! natural orbital labels
      integer :: ia, ib, ic, id ! atomic orbital labels
      integer :: la, lb, lc, ld ! atomic orbital shell labels
      integer :: na, nb, nc, nd ! number of shell functions
c
      integer :: ni, nj ! number of natural orbitals
      integer :: jjj ! counter over sub-ranges of jj
c
      integer :: ia_lo, ia_hi ! a-index atomic orbital limits
      integer :: ib_lo, ib_hi ! b-index atomic orbital limits
      integer :: ic_lo, ic_hi ! c-index atomic orbital limits
      integer :: id_lo, id_hi ! d-index atomic orbital limits
c
      integer :: ii_lo, ii_hi ! i-index natural orbital limits
      integer :: jj_lo, jj_hi ! j-index natural orbital limits
c
      integer :: if_lo, if_hi ! i-index Fock matrix limits
      integer :: jf_lo, jf_hi ! i-index Fock matrix limits
      integer :: ldf          ! leading dimension on Fock matrix
      integer :: idxf         ! index for Fock matrix in local memory
      integer :: ix_lo, ix_hi ! i-index exchange occ. matrix limits
      integer :: jx_lo, jx_hi ! i-index exchange occ. matrix limits
      integer :: ldx          ! leading dimension on exchange occ matrix
      integer :: idxx         ! index for exchange occ. matrix in memory
c
      integer :: max2e  ! quartet maximum no. 2-el integrals
      integer :: mem2   ! amount of scratch space needed
      integer :: maxsbf ! maximum no. of basis functions in a shell
      integer :: nshell ! the number of shells
c
      logical :: ok_dist ! is the data distribution OK?
c
      double precision :: e_iiii_ab, e_iiii_ba
      double precision :: e_iijj_ab, e_iijj_ba
      double precision :: p_a,       p_b
      double precision :: p_a_12,    p_b_12
      double precision :: p1p_a_12,  p1p_b_12
      double precision :: p1p_a_14,  p1p_b_14
      double precision :: p1p_a_34,  p1p_b_34
      double precision :: dp_a_12,   dp_b_12
      double precision :: dp1p_a_12, dp1p_b_12
      double precision :: dp1p_a_14, dp1p_b_14
c
      double precision, allocatable :: occ_a(:) ! a-occupation numbers
      double precision, allocatable :: occ_b(:) ! b-occupation numbers
c
c     Data structure for the electron repulsion integrals, as well as
c     2RDM blocks for the density matrix of [5] and the conventional
c     Hartree-Fock 2RDM.
c
      double precision, allocatable         :: scr(:)
      double precision, allocatable, target :: buf_eri(:)
      double precision, pointer             :: eri(:,:,:,:)
c
c     Intermediates in the 2RDM construction
c
      double precision, allocatable, target :: buf_e_aci_ab(:)
      double precision, pointer             :: e_aci_ab(:,:,:)
      double precision, allocatable, target :: buf_e_aci_ba(:)
      double precision, pointer             :: e_aci_ba(:,:,:)
c
      double precision, allocatable, target :: buf_e2_acj_ab(:)
      double precision, pointer             :: e2_acj_ab(:,:,:)
      double precision, allocatable, target :: buf_e2_acj_ba(:)
      double precision, pointer             :: e2_acj_ba(:,:,:)
c
      double precision, allocatable, target :: buf_e4_abj_ab(:)
      double precision, pointer             :: e4_abj_ab(:,:,:)
      double precision, allocatable, target :: buf_e4_abj_ba(:)
      double precision, pointer             :: e4_abj_ba(:,:,:)
c
c     For the Fock matrices for the natural orbitals
c
c     - Partially transformed
c
      double precision, allocatable, target :: buf_fn_ic_a(:)
      double precision, pointer             :: fn_ic_a(:,:)
      double precision, allocatable, target :: buf_fn_ic_b(:)
      double precision, pointer             :: fn_ic_b(:,:)
      double precision, allocatable, target :: buf_fn_ib_a(:)
      double precision, pointer             :: fn_ib_a(:,:)
      double precision, allocatable, target :: buf_fn_ib_b(:)
      double precision, pointer             :: fn_ib_b(:,:)
c
c     - Same as above but fully transformed
c
      double precision, allocatable, target :: buf_fn_ij_a(:)
      double precision, pointer             :: fn_ij_a(:,:)
      double precision, allocatable, target :: buf_fn_ij_b(:)
      double precision, pointer             :: fn_ij_b(:,:)
c
c     For the Fock matrices for the correlation functions
c
      double precision, allocatable, target :: buf_fc_ij_a(:)
      double precision, pointer             :: fc_ij_a(:,:)
      double precision, allocatable, target :: buf_fc_ij_b(:)
      double precision, pointer             :: fc_ij_b(:,:)
      double precision, allocatable, target :: buf_fc_ji_a(:)
      double precision, pointer             :: fc_ji_a(:,:)
      double precision, allocatable, target :: buf_fc_ji_b(:)
      double precision, pointer             :: fc_ji_b(:,:)
c
c     Orbital coefficients
c
      double precision, allocatable, target :: buf_N_di_a(:)
      double precision, pointer             :: N_di_a(:,:)
      double precision, allocatable, target :: buf_N_di_b(:)
      double precision, pointer             :: N_di_b(:,:)
      double precision, allocatable, target :: buf_N_ci_a(:)
      double precision, pointer             :: N_ci_a(:,:)
      double precision, allocatable, target :: buf_N_ci_b(:)
      double precision, pointer             :: N_ci_b(:,:)
      double precision, allocatable, target :: buf_N_bi_a(:)
      double precision, pointer             :: N_bi_a(:,:)
      double precision, allocatable, target :: buf_N_bi_b(:)
      double precision, pointer             :: N_bi_b(:,:)
      double precision, allocatable, target :: buf_N_ai_a(:)
      double precision, pointer             :: N_ai_a(:,:)
      double precision, allocatable, target :: buf_N_ai_b(:)
      double precision, pointer             :: N_ai_b(:,:)
c
      double precision :: f_a
      double precision :: b_ii
      double precision :: b_ij
      double precision :: dbii_ab
      double precision :: dbii_ba
      double precision :: dbij_ab
      double precision :: dbij_ba
      double precision :: k1
      double precision :: k2
      double precision :: dk1_ab
      double precision :: dk1_ba
      double precision :: dk2_ab
      double precision :: dk2_ba
      double precision :: dT_ab
      double precision :: dT_ba
c
      double precision :: c_a_j
      double precision :: c_b_j
      double precision :: Trenorm
      logical          :: oTrenorm
cDEBUG
      double precision E_ii_cor
      double precision E2_ij_cor
      double precision E4_ij_cor
      double precision c_ii
      double precision c2_ii
      double precision c2_ij
cDEBUG
c
c     Functions:
c
      double precision, external :: ddot
c
c     Code:
c
      nproc = ga_nnodes()
      iproc = ga_nodeid()
      itask = -1
c
      E_corr    = 0.0d0
cDEBUG
      E_ii_cor  = 0.0d0
      E2_ij_cor = 0.0d0
      E4_ij_cor = 0.0d0
      b_ii      = 0.0d0
      c2_ii     = 0.0d0
      b_ij      = 0.0d0
cDEBUG
c
      nbf  = wfn1_param%nbf
      nmo  = wfn1_param%nmo
      ne_a = wfn1_param%nea
      ne_b = wfn1_param%neb
      f_a  = wfn1_param%fac_a
c
      if (.not. bas_numcont(wfn1_inst%basis, nshell)) call errquit
     &     ('wfn1_e_g_2el_corr: bas_numcont failed for basis',
     &      wfn1_inst%basis, BASIS_ERR)
      if (.not. bas_nbf_cn_max(wfn1_inst%basis, maxsbf)) call errquit
     &     ('wfn1_e_g_2el_corr: bas_nbf_cn_max failed for basis',
     &      wfn1_inst%basis, BASIS_ERR)
c
      call ga_distribution(wfn1_deriv%g_dna,0,ii_lo,ii_hi,jj_lo,jj_hi)
      ni = ii_hi-ii_lo+1
      nj = jj_hi-jj_lo+1
      call int_mem_2e4c(max2e,mem2)
c
#ifdef TEST_RDMS
c     allocate(da(nbf,nbf),db(nbf,nbf))
c     allocate(gaa(nbf,nbf,nbf,nbf))
c     allocate(gab(nbf,nbf,nbf,nbf))
c     allocate(gbb(nbf,nbf,nbf,nbf))
c     da  = 0.0d0
c     db  = 0.0d0
c     gaa = 0.0d0
c     gab = 0.0d0
c     gbb = 0.0d0
#endif
c
      allocate(occ_a(1:nmo),occ_b(1:nmo))
      allocate(scr(mem2))
      allocate(buf_eri(max2e))
c
      allocate(buf_e_aci_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e_aci_ba(maxsbf*maxsbf*nmo))
      allocate(buf_e2_acj_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e2_acj_ba(maxsbf*maxsbf*nmo))
      allocate(buf_e4_abj_ab(maxsbf*maxsbf*nmo))
      allocate(buf_e4_abj_ba(maxsbf*maxsbf*nmo))
c
      allocate(buf_N_ai_a(maxsbf*nmo),buf_N_ai_b(maxsbf*nmo))
      allocate(buf_N_bi_a(maxsbf*nmo),buf_N_bi_b(maxsbf*nmo))
      allocate(buf_N_ci_a(maxsbf*nmo),buf_N_ci_b(maxsbf*nmo))
      allocate(buf_N_di_a(maxsbf*nmo),buf_N_di_b(maxsbf*nmo))
c
      allocate(buf_fn_ic_a(nmo*maxsbf),buf_fn_ic_b(nmo*maxsbf))
      allocate(buf_fn_ib_a(nmo*maxsbf),buf_fn_ib_b(nmo*maxsbf))
      allocate(buf_fn_ij_a(nmo*nj),    buf_fn_ij_b(nmo*nj))
c
      allocate(buf_fc_ij_a(nmo*nj))
      allocate(buf_fc_ij_b(nmo*nj))
      allocate(buf_fc_ji_a(nj*nmo))
      allocate(buf_fc_ji_b(nj*nmo))
c
c     Calculate occupation numbers
c     ----------------------------
c
c     Calculate alpha-occupation numbers
c
      call wfn1_calc_occ(wfn1_wave%g_ca,nmo,ne_a,wfn1_wave%icnfa,
     &                   wfn1_wave%dcnta,occ_a)
c
c     Calculate beta-occupation numbers
c
      call wfn1_calc_occ(wfn1_wave%g_cb,nmo,ne_b,wfn1_wave%icnfb,
     &                   wfn1_wave%dcntb,occ_b)
c
      call ga_sync()
c
c     Calculate renormalization quantities
c
      do ii = 1, nmo
        b_ii  = b_ii  + sqrt(occ_a(ii)*occ_b(ii))-occ_a(ii)*occ_b(ii)
        do jj = 1, ii-1
          b_ij = b_ij + sqrt(occ_a(ii)*(1.0d0-occ_a(ii))*
     &                       occ_b(jj)*(1.0d0-occ_b(jj)))
        enddo
        do jj = ii+1, nmo
          b_ij = b_ij + sqrt(occ_a(ii)*(1.0d0-occ_a(ii))*
     &                       occ_b(jj)*(1.0d0-occ_b(jj)))
        enddo
      enddo
      oTrenorm = .true.
      if (b_ij.le.b_ii) then
c       If there is no correlation then b_ii and b_ij are both 0
c       In that case the renormalization factor is 1 and its derivatives
c       are 0.
        oTrenorm = .false. 
        k1       = 1.0d0
        k2       = 1.0d0
        Trenorm  = 1.0d0
      else
        oTrenorm = .true.
        k1       = b_ii/b_ij
        k2       = 2.0d0*b_ii/(b_ii+b_ij)
        Trenorm  = (1.0d0-f_a)*k1+f_a*k2
      endif
cDEBUG
      do ii = 1, nmo
        c_ii  = c_ii  + sqrt(occ_a(ii)*occ_b(ii))-occ_a(ii)*occ_b(ii)
        c2_ii = c2_ii + sqrt(occ_a(ii)*(1.0d0-occ_a(ii))*
     &                       occ_b(ii)*(1.0d0-occ_b(ii)))
        do jj = 1, ii-1
          c2_ij = c2_ij + sqrt(occ_a(ii)*(1.0d0-occ_a(ii))*
     &                         occ_b(jj)*(1.0d0-occ_b(jj)))
        enddo
        do jj = ii+1, nmo
          c2_ij = c2_ij + sqrt(occ_a(ii)*(1.0d0-occ_a(ii))*
     &                         occ_b(jj)*(1.0d0-occ_b(jj)))
        enddo
      enddo
c     write(*,'(" HVD: c_ii        = ",e22.8)')c_ii
c     write(*,'(" HVD: c2_ij       = ",e22.8)')c2_ij
c     write(*,'(" HVD: c2_IJ       = ",e22.8)')c2_ij+c2_ii
c     write(*,'(" HVD: c_ii/c2_ij  = ",e22.8)')c_ii/c2_ij
c     write(*,'(" HVD: c_ii/c2_IJ  = ",e22.8)')2.0d0*c_ii/(c2_ij+c2_ii)
cDEBUG
c
      do ld = 1, nshell
        if (.not. bas_cn2bfr(wfn1_inst%basis, ld, id_lo, id_hi))
     &      call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                   wfn1_inst%basis, BASIS_ERR)
c
        nd = id_hi-id_lo+1
        N_di_a(id_lo:id_hi,1:nmo) => buf_N_di_a
        N_di_b(id_lo:id_hi,1:nmo) => buf_N_di_b
        call ga_get(wfn1_wave%g_na,id_lo,id_hi,1,nmo,N_di_a,nd)
        call ga_get(wfn1_wave%g_nb,id_lo,id_hi,1,nmo,N_di_b,nd)
c
        do lb = 1, nshell
          if (.not. bas_cn2bfr(wfn1_inst%basis, lb, ib_lo, ib_hi))
     &        call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                     wfn1_inst%basis, BASIS_ERR)
c
          nb = ib_hi-ib_lo+1
          N_bi_a(ib_lo:ib_hi,1:nmo) => buf_N_bi_a
          N_bi_b(ib_lo:ib_hi,1:nmo) => buf_N_bi_b
          call ga_get(wfn1_wave%g_na,ib_lo,ib_hi,1,nmo,N_bi_a,nb)
          call ga_get(wfn1_wave%g_nb,ib_lo,ib_hi,1,nmo,N_bi_b,nb)
c
          do lc = 1, nshell 
            if (.not. bas_cn2bfr(wfn1_inst%basis, lc, ic_lo, ic_hi))
     &          call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                       wfn1_inst%basis, BASIS_ERR)
c
            nc = ic_hi-ic_lo+1
            N_ci_a(ic_lo:ic_hi,1:nmo) => buf_N_ci_a
            N_ci_b(ic_lo:ic_hi,1:nmo) => buf_N_ci_b
            call ga_get(wfn1_wave%g_na,ic_lo,ic_hi,1,nmo,N_ci_a,nc)
            call ga_get(wfn1_wave%g_nb,ic_lo,ic_hi,1,nmo,N_ci_b,nc)
c
            do la = 1, nshell
              itask = itask + 1
              if (mod(itask,nproc).ne.iproc) cycle
              if (.not. bas_cn2bfr(wfn1_inst%basis, la, ia_lo, ia_hi))
     &            call errquit('wfn1_e_g_2el_corr: bas_cn2bfr',
     &                         wfn1_inst%basis, BASIS_ERR)
c
              na = ia_hi-ia_lo+1
              N_ai_a(ia_lo:ia_hi,1:nmo) => buf_N_ai_a
              N_ai_b(ia_lo:ia_hi,1:nmo) => buf_N_ai_b
              call ga_get(wfn1_wave%g_na,ia_lo,ia_hi,1,nmo,N_ai_a,na)
              call ga_get(wfn1_wave%g_nb,ia_lo,ia_hi,1,nmo,N_ai_b,na)
c
c             Set up eri buffers
c
              eri(ia_lo:ia_hi,ic_lo:ic_hi,ib_lo:ib_hi,id_lo:id_hi)
     &        => buf_eri
c
              e_aci_ab(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e_aci_ab
              e_aci_ba(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e_aci_ba
              e2_acj_ab(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e2_acj_ab
              e2_acj_ba(ia_lo:ia_hi,ic_lo:ic_hi,1:nmo)
     &        => buf_e2_acj_ba
              e4_abj_ab(ia_lo:ia_hi,ib_lo:ib_hi,1:nmo)
     &        => buf_e4_abj_ab
              e4_abj_ba(ia_lo:ia_hi,ib_lo:ib_hi,1:nmo)
     &        => buf_e4_abj_ba
c
              e_aci_ab  = 0.0d0
              e_aci_ba  = 0.0d0
              e2_acj_ab = 0.0d0
              e2_acj_ba = 0.0d0
              e4_abj_ab = 0.0d0
              e4_abj_ba = 0.0d0
c
c             Calculate the 2-electron integrals
c
              call int_2e4c(wfn1_inst%basis, ld, lb,
     &                      wfn1_inst%basis, lc, la,
     &                      mem2, scr, max2e, eri)
c
              do id = id_lo, id_hi
                do ib = ib_lo, ib_hi
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      do ii = 1, nmo
                        e_aci_ab(ia,ic,ii) = e_aci_ab(ia,ic,ii)
     &                  + eri(ia,ic,ib,id)*N_bi_b(ib,ii)*N_di_b(id,ii)
                        e_aci_ba(ia,ic,ii) = e_aci_ba(ia,ic,ii)
     &                  + eri(ia,ic,ib,id)*N_bi_a(ib,ii)*N_di_a(id,ii)
                        e4_abj_ab(ia,ib,ii) = e4_abj_ab(ia,ib,ii)
     &                  + eri(ia,ic,ib,id)*N_ci_a(ic,ii)*N_di_b(id,ii)
                        e4_abj_ba(ia,ib,ii) = e4_abj_ba(ia,ib,ii)
     &                  + eri(ia,ic,ib,id)*N_ci_b(ic,ii)*N_di_a(id,ii)
                      enddo ! ii
                    enddo ! ia
                  enddo ! ic
                enddo ! ib
              enddo ! id
              do ii = 1, nmo
                do ic = ic_lo, ic_hi
                  do ia = ia_lo, ia_hi
                    e2_acj_ab(ia,ic,ii) = e_aci_ab(ia,ic,ii)
                    e2_acj_ba(ia,ic,ii) = e_aci_ba(ia,ic,ii)
                  enddo ! ia
                enddo ! ic
              enddo ! ii
              do ic = ic_lo, ic_hi
                do ia = ia_lo, ia_hi
                  do jj = 1, nmo
                    e2_acj_ab(ia,ic,jj) = e2_acj_ab(ia,ic,jj)
     &              * sqrt(occ_b(jj)*(1.0d0-occ_b(jj)))
                    e2_acj_ba(ia,ic,jj) = e2_acj_ba(ia,ic,jj)
     &              * sqrt(occ_a(jj)*(1.0d0-occ_a(jj)))
                  enddo ! jj
                enddo ! ia
              enddo ! ic
              do ib = ib_lo, ib_hi
                do ia = ia_lo, ia_hi
                  do jj = 1, nmo
                    e4_abj_ab(ia,ib,jj) = e4_abj_ab(ia,ib,jj)
     &              * sqrt(sqrt(occ_b(jj)*(1.0d0-occ_b(jj))))
                    e4_abj_ba(ia,ib,jj) = e4_abj_ba(ia,ib,jj)
     &              * sqrt(sqrt(occ_a(jj)*(1.0d0-occ_a(jj))))
                  enddo ! jj
                enddo ! ia
              enddo ! ib
c
c             Calculate the energy contributions
c
              do ic = ic_lo, ic_hi
                do ia = ia_lo, ia_hi
                  do ii = 1, nmo
                    E_corr = E_corr
     &              + e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &              * (sqrt(occ_a(ii)*occ_b(ii))-occ_a(ii)*occ_b(ii))
     &              + e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &              * (sqrt(occ_b(ii)*occ_a(ii))-occ_b(ii)*occ_a(ii))
cDEBUG
                    E_ii_cor = E_ii_cor
     &              + e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &              * (sqrt(occ_a(ii)*occ_b(ii))-occ_a(ii)*occ_b(ii))
     &              + e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &              * (sqrt(occ_b(ii)*occ_a(ii))-occ_b(ii)*occ_a(ii))
cDEBUG
                    do jj = 1, ii-1
                      E_corr = E_corr
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
cDEBUG
                      E2_ij_cor = E2_ij_cor
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
cDEBUG
                    enddo ! jj
                    do jj = ii+1, nmo
                      E_corr = E_corr
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
cDEBUG
                      E2_ij_cor = E2_ij_cor
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
cDEBUG
                    enddo ! jj
                  enddo ! ii
                enddo ! ia
              enddo ! ic
c
              do ib = ib_lo, ib_hi
                do ia = ia_lo, ia_hi
                  do ii = 1, nmo
                    do jj = 1, ii-1
                      E_corr = E_corr
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
cDEBUG
                      E4_ij_cor = E4_ij_cor
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
cDEBUG
                    enddo ! jj
                    do jj = ii+1, nmo
                      E_corr = E_corr
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
cDEBUG
                      E4_ij_cor = E4_ij_cor
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)*N_bi_b(ib,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)*N_bi_a(ib,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
cDEBUG
                    enddo ! jj
                  enddo ! ii
                enddo ! ia
              enddo ! ib
c
c             Construct contributions to the natural orbital Fock
c             matrices.
c
c             - First do the T_ii terms
c
              fn_ic_a(1:nmo,ic_lo:ic_hi) => buf_fn_ic_a
              fn_ic_b(1:nmo,ic_lo:ic_hi) => buf_fn_ic_b
              fn_ic_a = 0.0d0
              fn_ic_b = 0.0d0
              do ii = 1, nmo
                do ic = ic_lo, ic_hi
                  do ia = ia_lo, ia_hi
                    fn_ic_a(ii,ic) = fn_ic_a(ii,ic)
     &              + e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)
     &              * (sqrt(occ_a(ii)*occ_b(ii))-occ_a(ii)*occ_b(ii))
                    fn_ic_b(ii,ic) = fn_ic_b(ii,ic)
     &              + e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)
     &              * (sqrt(occ_b(ii)*occ_a(ii))-occ_b(ii)*occ_a(ii))
                  enddo ! ia
                enddo ! ic
              enddo ! ii
c
c             - Second do the T2_ij terms
c
              do jj = 1, nmo
                do ii = 1, jj-1
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      fn_ic_a(ii,ic) = fn_ic_a(ii,ic)
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
                      fn_ic_b(ii,ic) = fn_ic_b(ii,ic)
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
                    enddo ! ia
                  enddo ! ic
                enddo ! ii
                do ii = jj+1, nmo
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      fn_ic_a(ii,ic) = fn_ic_a(ii,ic)
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)
     &                * sqrt(occ_a(ii)*(1.0d0-occ_a(ii)))*Trenorm
                      fn_ic_b(ii,ic) = fn_ic_b(ii,ic)
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)
     &                * sqrt(occ_b(ii)*(1.0d0-occ_b(ii)))*Trenorm
                    enddo ! ia
                  enddo ! ic
                enddo ! ii
              enddo ! jj
c
c             - Third do the T4_ij terms
c
              fn_ib_a(1:nmo,ib_lo:ib_hi) => buf_fn_ib_a
              fn_ib_b(1:nmo,ib_lo:ib_hi) => buf_fn_ib_b
              fn_ib_a = 0.0d0
              fn_ib_b = 0.0d0
              do jj = 1, nmo
                do ii = 1, jj-1
                  do ib = ib_lo, ib_hi
                    do ia = ia_lo, ia_hi
                      fn_ib_b(ii,ib) = fn_ib_b(ii,ib)
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
                      fn_ib_a(ii,ib) = fn_ib_a(ii,ib)
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
                    enddo ! ia
                  enddo ! ib
                enddo ! ii
                do ii = jj+1, nmo
                  do ib = ib_lo, ib_hi
                    do ia = ia_lo, ia_hi
                      fn_ib_b(ii,ib) = fn_ib_b(ii,ib)
     &                - e4_abj_ab(ia,ib,jj)*N_ai_a(ia,ii)
     &                * sqrt(sqrt(occ_a(ii)*(1.0d0-occ_a(ii))))*Trenorm
                      fn_ib_a(ii,ib) = fn_ib_a(ii,ib)
     &                - e4_abj_ba(ia,ib,jj)*N_ai_b(ia,ii)
     &                * sqrt(sqrt(occ_b(ii)*(1.0d0-occ_b(ii))))*Trenorm
                    enddo ! ia
                  enddo ! ib
                enddo ! ii
              enddo ! jj
c
c             - Fourth transform to natural orbital basis and accumulate
c
              do jj = 1, nmo, nj
                fn_ij_a(1:nmo,jj:min(nmo,jj+nj-1)) => buf_fn_ij_a
                fn_ij_b(1:nmo,jj:min(nmo,jj+nj-1)) => buf_fn_ij_b
                fn_ij_a = 0.0d0
                fn_ij_b = 0.0d0
                do jjj = jj, min(nmo,jj+nj-1)
                  do ic = ic_lo, ic_hi
                    do ii = 1, nmo
                      fn_ij_a(ii,jjj) = fn_ij_a(ii,jjj)
     &                    + fn_ic_a(ii,ic)*N_ci_a(ic,jjj)
                      fn_ij_b(ii,jjj) = fn_ij_b(ii,jjj)
     &                    + fn_ic_b(ii,ic)*N_ci_b(ic,jjj)
                    enddo ! ii
                  enddo ! ic
                  do ib = ib_lo, ib_hi
                    do ii = 1, nmo
                      fn_ij_a(ii,jjj) = fn_ij_a(ii,jjj)
     &                  + fn_ib_a(ii,ib)*N_bi_a(ib,jjj)
                      fn_ij_b(ii,jjj) = fn_ij_b(ii,jjj)
     &                  + fn_ib_b(ii,ib)*N_bi_b(ib,jjj)
                    enddo ! ii
                  enddo ! id
                enddo ! jjj
                call ga_acc(wfn1_deriv%g_dna,1,nmo,jj,min(nmo,jj+nj-1),
     &                      fn_ij_a,nmo,1.0d0)
                call ga_acc(wfn1_deriv%g_dnb,1,nmo,jj,min(nmo,jj+nj-1),
     &                      fn_ij_b,nmo,1.0d0)
              enddo ! jj 
c
c             Construct contributions to the correlation function Fock
c             matrices.
c
c             - First do the T_ii terms
c
              do ii = 1, nmo
                e_iiii_ab = 0.0d0
                e_iiii_ba = 0.0d0
                do ic = ic_lo, ic_hi
                  do ia = ia_lo, ia_hi
                    e_iiii_ab = e_iiii_ab
     &              + e_aci_ab(ia,ic,ii)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
                    e_iiii_ba = e_iiii_ba
     &              + e_aci_ba(ia,ic,ii)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
                  enddo ! ia
                enddo ! ic
                p_a = occ_a(ii)
                p_b = occ_b(ii)
                p_a_12 = sqrt(p_a)
                p_b_12 = sqrt(p_b)
                dp_a_12 = 1.0d0/max(wfn1_param%denom_min,2.0d0*p_a_12)
                dp_b_12 = 1.0d0/max(wfn1_param%denom_min,2.0d0*p_b_12)
                v_dc_a(ii) = v_dc_a(ii)
     &          + e_iiii_ab*(dp_a_12*p_b_12-p_b)
                v_dc_b(ii) = v_dc_b(ii)
     &          + e_iiii_ba*(p_a_12*dp_b_12-p_a)
              enddo ! ii
c
c             - Second do the T2_ij terms
c
              do ii = 1, nmo
                e_iijj_ab = 0.0d0
                e_iijj_ba = 0.0d0
                do jj = 1, ii-1
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      e_iijj_ab = e_iijj_ab
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
                      e_iijj_ba = e_iijj_ba
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
                    enddo ! ia
                  enddo ! ic
                enddo ! jj
                do jj = ii+1, nmo
                  do ic = ic_lo, ic_hi
                    do ia = ia_lo, ia_hi
                      e_iijj_ab = e_iijj_ab
     &                - e2_acj_ab(ia,ic,jj)*N_ai_a(ia,ii)*N_ci_a(ic,ii)
                      e_iijj_ba = e_iijj_ba
     &                - e2_acj_ba(ia,ic,jj)*N_ai_b(ia,ii)*N_ci_b(ic,ii)
                    enddo ! ia
                  enddo ! ic
                enddo ! jj
                p_a = occ_a(ii)
                p_b = occ_b(ii)
                p_a_12 = sqrt(p_a)
                p_b_12 = sqrt(p_b)
                p1p_a_12 = sqrt(p_a*(1.0d0-p_a))
                p1p_b_12 = sqrt(p_b*(1.0d0-p_b))
                dp_a_12 = 1.0d0/max(wfn1_param%denom_min,2.0d0*p_a_12)
                dp_b_12 = 1.0d0/max(wfn1_param%denom_min,2.0d0*p_b_12)
                dp1p_a_12 = (1.0d0-2.0d0*p_a)/
     &                      max(wfn1_param%denom_min,2.0d0*p1p_a_12)
                dp1p_b_12 = (1.0d0-2.0d0*p_b)/
     &                      max(wfn1_param%denom_min,2.0d0*p1p_b_12)
                v_dc_a(ii) = v_dc_a(ii)
     &          + e_iijj_ab*dp1p_a_12*Trenorm
                v_dc_b(ii) = v_dc_b(ii)
     &          + e_iijj_ba*dp1p_b_12*Trenorm
                if (oTrenorm) then
                  c_b_j = 0.0d0
                  c_a_j = 0.0d0
                  do jj = 1, ii-1
                    c_a_j = c_a_j + sqrt(occ_a(jj)*(1.0d0-occ_a(jj)))
                    c_b_j = c_b_j + sqrt(occ_b(jj)*(1.0d0-occ_b(jj)))
                  enddo
                  do jj = ii+1, nmo
                    c_a_j = c_a_j + sqrt(occ_a(jj)*(1.0d0-occ_a(jj)))
                    c_b_j = c_b_j + sqrt(occ_b(jj)*(1.0d0-occ_b(jj)))
                  enddo
                  dbii_ab = p_b_12*dp_a_12-p_b
                  dbii_ba = p_a_12*dp_b_12-p_a
                  dbij_ab = dp1p_a_12*c_b_j
                  dbij_ba = dp1p_b_12*c_a_j
                  dk1_ab = dbii_ab/b_ij - b_ii/(b_ij**2)*dbij_ab
                  dk1_ba = dbii_ba/b_ij - b_ii/(b_ij**2)*dbij_ba
                  dk2_ab = 2.0d0*dbii_ab/(b_ii+b_ij)
     &                   - 2.0d0*b_ii/(b_ii+b_ij)**2*(dbii_ab+dbij_ab)
                  dk2_ba = 2.0d0*dbii_ba/(b_ii+b_ij)
     &                   - 2.0d0*b_ii/(b_ii+b_ij)**2*(dbii_ba+dbij_ba)
                  dT_ab = (1.0d0-f_a)*dk1_ab+f_a*dk2_ab
                  dT_ba = (1.0d0-f_a)*dk1_ba+f_a*dk2_ba
                  v_dc_a(ii) = v_dc_a(ii)
     &            + e_iijj_ab*p1p_a_12*dT_ab
                  v_dc_b(ii) = v_dc_b(ii)
     &            + e_iijj_ba*p1p_b_12*dT_ba
                endif
              enddo ! ii
c
c             - Third do the T4_ij terms
c
              do jj = 1, nmo, nj
                do jjj = jj, min(nmo,jj+nj-1)
                  do ii = 1, jjj-1
                    e_iijj_ab = 0.0d0
                    e_iijj_ba = 0.0d0
                    do ib = ib_lo, ib_hi
                      do ia = ia_lo, ia_hi
                        e_iijj_ab = -e4_abj_ab(ia,ib,jjj)*
     &                               N_ai_a(ia,ii)*N_bi_b(ib,ii)
                        e_iijj_ba = -e4_abj_ba(ia,ib,jjj)*
     &                               N_ai_b(ia,ii)*N_bi_a(ib,ii)
                      enddo ! ia
                    enddo ! ib
                    p_a = occ_a(ii)
                    p_b = occ_b(ii)
                    p1p_a_12 = sqrt(p_a*(1.0d0-p_a))
                    p1p_b_12 = sqrt(p_b*(1.0d0-p_b))
                    p1p_a_14 = sqrt(sqrt(p_a*(1.0d0-p_a)))
                    p1p_b_14 = sqrt(sqrt(p_b*(1.0d0-p_b)))
                    p1p_a_34 = p1p_a_14**3
                    p1p_b_34 = p1p_b_14**3
                    dp1p_a_12 = (1.0d0-2.0d0*p_a)/
     &                     max(wfn1_param%denom_min,2.0d0*p1p_a_12)
                    dp1p_b_12 = (1.0d0-2.0d0*p_b)/
     &                     max(wfn1_param%denom_min,2.0d0*p1p_b_12)
                    dp1p_a_14 = (1.0d0-2.0d0*p_a)/
     &                     max(wfn1_param%denom_min,4.0d0*p1p_a_34)
                    dp1p_b_14 = (1.0d0-2.0d0*p_b)/
     &                     max(wfn1_param%denom_min,4.0d0*p1p_b_34)
                    v_dc_a(ii) = v_dc_a(ii)
     &              + e_iijj_ab*dp1p_a_14*Trenorm
                    v_dc_b(ii) = v_dc_b(ii)
     &              + e_iijj_ba*dp1p_b_14*Trenorm
                    if (oTrenorm) then
                      c_b_j = 0.0d0
                      c_a_j = 0.0d0
                      do kk = 1, ii-1
                        c_a_j = c_a_j + sqrt(occ_a(kk)*(1.d0-occ_a(kk)))
                        c_b_j = c_b_j + sqrt(occ_b(kk)*(1.d0-occ_b(kk)))
                      enddo
                      do kk = ii+1, nmo
                        c_a_j = c_a_j + sqrt(occ_a(kk)*(1.d0-occ_a(kk)))
                        c_b_j = c_b_j + sqrt(occ_b(kk)*(1.d0-occ_b(kk)))
                      enddo
                      dbii_ab = p_b_12*dp_a_12-p_b
                      dbii_ba = p_a_12*dp_b_12-p_a
                      dbij_ab = dp1p_a_12*c_b_j
                      dbij_ba = dp1p_b_12*c_a_j
                      dk1_ab = dbii_ab/b_ij - b_ii/(b_ij**2)*dbij_ab
                      dk1_ba = dbii_ba/b_ij - b_ii/(b_ij**2)*dbij_ba
                      dk2_ab = 2.0d0*dbii_ab/(b_ii+b_ij)
     &                       - 2.0d0*b_ii/(b_ii+b_ij)**2
     &                              *(dbii_ab+dbij_ab)
                      dk2_ba = 2.0d0*dbii_ba/(b_ii+b_ij)
     &                       - 2.0d0*b_ii/(b_ii+b_ij)**2
     &                              *(dbii_ba+dbij_ba)
                      dT_ab = (1.0d0-f_a)*dk1_ab+f_a*dk2_ab
                      dT_ba = (1.0d0-f_a)*dk1_ba+f_a*dk2_ba
                      v_dc_a(ii) = v_dc_a(ii)
     &                + e_iijj_ab*p1p_a_14*dT_ab
                      v_dc_b(ii) = v_dc_b(ii)
     &                + e_iijj_ba*p1p_b_14*dT_ba
                    endif
                  enddo ! ii
                  do ii = jjj+1, nmo
                    e_iijj_ab = 0.0d0
                    e_iijj_ba = 0.0d0
                    do ib = ib_lo, ib_hi
                      do ia = ia_lo, ia_hi
                        e_iijj_ab = -e4_abj_ab(ia,ib,jjj)*
     &                               N_ai_a(ia,ii)*N_bi_b(ib,ii)
                        e_iijj_ba = -e4_abj_ba(ia,ib,jjj)*
     &                               N_ai_b(ia,ii)*N_bi_a(ib,ii)
                      enddo ! ia
                    enddo ! ib
                    p_a = occ_a(ii)
                    p_b = occ_b(ii)
                    p1p_a_12 = sqrt(p_a*(1.0d0-p_a))
                    p1p_b_12 = sqrt(p_b*(1.0d0-p_b))
                    p1p_a_14 = sqrt(sqrt(p_a*(1.0d0-p_a)))
                    p1p_b_14 = sqrt(sqrt(p_b*(1.0d0-p_b)))
                    dp1p_a_12 = (1.0d0-2.0d0*p_a)/
     &                     max(wfn1_param%denom_min,2.0d0*p1p_a_12)
                    dp1p_b_12 = (1.0d0-2.0d0*p_b)/
     &                     max(wfn1_param%denom_min,2.0d0*p1p_b_12)
                    dp1p_a_14 = (1.0d0-2.0d0*p_a)/
     &                     max(wfn1_param%denom_min,4.0d0*p1p_a_14**3)
                    dp1p_b_14 = (1.0d0-2.0d0*p_b)/
     &                     max(wfn1_param%denom_min,4.0d0*p1p_b_14**3)
                    v_dc_a(ii) = v_dc_a(ii)
     &              + e_iijj_ab*dp1p_a_14*Trenorm
                    v_dc_b(ii) = v_dc_b(ii)
     &              + e_iijj_ba*dp1p_b_14*Trenorm
                    if (oTrenorm) then
                      c_b_j = 0.0d0
                      c_a_j = 0.0d0
                      do kk = 1, ii-1
                        c_a_j = c_a_j + sqrt(occ_a(kk)*(1.d0-occ_a(kk)))
                        c_b_j = c_b_j + sqrt(occ_b(kk)*(1.d0-occ_b(kk)))
                      enddo
                      do kk = ii+1, nmo
                        c_a_j = c_a_j + sqrt(occ_a(kk)*(1.d0-occ_a(kk)))
                        c_b_j = c_b_j + sqrt(occ_b(kk)*(1.d0-occ_b(kk)))
                      enddo
                      dbii_ab = p_b_12*dp_a_12-p_b
                      dbii_ba = p_a_12*dp_b_12-p_a
                      dbij_ab = dp1p_a_12*c_b_j
                      dbij_ba = dp1p_b_12*c_a_j
                      dk1_ab = dbii_ab/b_ij - b_ii/(b_ij**2)*dbij_ab
                      dk1_ba = dbii_ba/b_ij - b_ii/(b_ij**2)*dbij_ba
                      dk2_ab = 2.0d0*dbii_ab/(b_ii+b_ij)
     &                       - 2.0d0*b_ii/(b_ii+b_ij)**2
     &                              *(dbii_ab+dbij_ab)
                      dk2_ba = 2.0d0*dbii_ba/(b_ii+b_ij)
     &                       - 2.0d0*b_ii/(b_ii+b_ij)**2
     &                              *(dbii_ba+dbij_ba)
                      dT_ab = (1.0d0-f_a)*dk1_ab+f_a*dk2_ab
                      dT_ba = (1.0d0-f_a)*dk1_ba+f_a*dk2_ba
                      v_dc_a(ii) = v_dc_a(ii)
     &                + e_iijj_ab*p1p_a_14*dT_ab
                      v_dc_b(ii) = v_dc_b(ii)
     &                + e_iijj_ba*p1p_b_14*dT_ba
                    endif
                  enddo ! ii
                enddo ! jjj
              enddo ! jj
c
            enddo ! la
          enddo ! lc
        enddo ! lb
      enddo ! ld
c
      E_corr    = 0.5d0*E_corr
cDEBUG
c     write(*,*)'HVD: E_ii_cor  = ',0.5d0*E_ii_cor
c     write(*,*)'HVD: E2_ij_cor = ',0.5d0*E2_ij_cor
c     write(*,*)'HVD: E4_ij_cor = ',0.5d0*E4_ij_cor
cDEBUG
c
      call ga_dgop(1300,E_corr,1,"+")
c
      deallocate(occ_a,occ_b)
      deallocate(buf_eri)
      deallocate(scr)
c
      deallocate(buf_e_aci_ab)
      deallocate(buf_e_aci_ba)
      deallocate(buf_e2_acj_ab)
      deallocate(buf_e2_acj_ba)
      deallocate(buf_e4_abj_ab)
      deallocate(buf_e4_abj_ba)
c
      deallocate(buf_N_ai_a,buf_N_ai_b)
      deallocate(buf_N_bi_a,buf_N_bi_b)
      deallocate(buf_N_ci_a,buf_N_ci_b)
      deallocate(buf_N_di_a,buf_N_di_b)
c
      deallocate(buf_fn_ic_a,buf_fn_ic_b)
      deallocate(buf_fn_ib_a,buf_fn_ib_b)
      deallocate(buf_fn_ij_a,buf_fn_ij_b)
c
      deallocate(buf_fc_ij_a)
      deallocate(buf_fc_ij_b)
      deallocate(buf_fc_ji_a)
      deallocate(buf_fc_ji_b)
c
      end
!>
!> @}
c
c-----------------------------------------------------------------------
